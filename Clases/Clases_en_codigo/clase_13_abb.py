# -*- coding: utf-8 -*-
"""Clase_13_ABB.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12EXM311xTWRg_pz9PHzS9dJaFc8BTUGm

# Clase 13: AB y ABB (Árbol de Búsqueda Binaria)
(Capítulo 9.9 del Apunte)

## Recuerdo Árboles Binarios (AB)

<div>
<img src="https://github.com/bpoblete/CC1002/raw/master/Clases/ab.png" alt="Ejemplo de AB" width=300 height=240 />
</div>

Cumplen alguna de las siguientes condiciones:
- Un AB es vacío, o
- Tiene un valor, un AB a la izquierda, y otro AB a la derecha

### Creación de un AB

Un AB es una estructura recursiva pues un **AB** contiene un valor (llamado raíz) y dos **AB**s adentro! 

**AB** = **valor** + **AB izquierdo** + **AB derecho**
"""

import estructura


#Arbol Binario
#AB: valor(any), izq(AB), der(AB)
estructura.crear("AB","valor izq der")


# creamos un AB

ab=AB("F",\
    AB("B",\
        AB("A",None,None),\
        AB("D",\
            AB("C",None,None),\
            AB("E",None,None))),\
    AB("G",\
        None,\
        AB("I",\
            AB("H", None, None),\
            None)))

print(ab)

print(ab.valor)
print(ab.izq)
print(ab.der)

print(ab.izq.valor) # dentro del sub-arbol izquierdo: la raiz
print(ab.izq.izq) # dentro del sub-arbol izquierdo: su sub-arbol izquierdo
print(ab.izq.der) # dentro del sub-arbol izquierdo: su sub-arbol izquierdo

"""### Vimos tareas típicas sobre un AB


- Crear un AB
- Contar los nodos de un AB
- Calcular la altura de un AB
- Contar las hojas de un AB

### Un tipo de Árbol Binario: **Un AB de expresiones aritméticas**

<div>
<img src="https://github.com/bpoblete/CC1002/raw/master/Clases/ab_expresion.png" alt="AB de  expresion aritmetica" width=180 height=180 />
</div>
"""

#arbol expresión
#AB con numeros en los valores de las hojas
#   y operadores en los valores de las no-hojas


ae=AB("-", \
      AB(2,None,None),\
      AB("*",\
         AB(3,None,None),\
         AB(4,None,None)))

#evaluar: AB -> num
#evalua expresión representada en AB
#ej: evaluar(ae) -> -10
def evaluar(A):

    assert type(A)==AB
    
    if A.izq==None and A.der==None: 
        return A.valor   
    
    a=evaluar(A.izq) #primer operando
    b=evaluar(A.der) #segundo operando
    op=A.valor       #operador

  
    if op=="+": 
        return a+b
    if op=="-": 
        return a-b
    if op=="*": 
        return a*b
    if op=="/": 
        return a/b

assert evaluar(ae)==-10

otroAE = AB("*",AB("+",AB(3,None,None),AB(4,None,None)),AB("/",AB(10,None,None),AB(5,None,None)))
print(otroAE)

print(evaluar(otroAE))

"""**Propuesto 1:**: Modificar la función anterior para que permita evaluar AB que representen expresiones aritméticas con exponenciación, como por ejemplo: 
```5+2**3```

En otras palabras, si 

```
ae2 = AB("+",AB(5,None,None),AB("**",AB(2,None,None),AB(3,None,None)))
```
entonces 


```
evaluar(ae2)
```
retorna 13.

**Propuesto 2:**: Modificar la función anterior para que permita evaluar AB que representen expresiones aritméticas con números negativos, como por ejemplo:  
```7+2*-3```

En otras palabras, si 

```
ae3 = AB("+",AB(5,None,None),AB("*",AB(2,None,None),AB("-",None,AB(3,None,None))))
```
entonces 


```
evaluar(ae3)
```
retorna 1.

*Pista*: Fijarse que el árbol de expresión aritmético para `-3` es el árbol para `0-3` pero reemplazando el subárbol con la hoja `0` por un `None`. Entonces, para evaluar árboles con negativos, sólo tiene que modificar la función para detectar si un árbol con "-" en la raíz representa (a) una resta (caso ya listo) o (b)  un número negativo.

## ABB: Árbol de Búsqueda Binaria

Un ABB es un árbol binario tal que:

- es un árbol vacío (None)

o sino,

- valores en el AB **izquierdo** son **menores** que el valor
- valores en el AB **derecho** son **mayores** que el valor
- AB izquierdo y AB derecho son también ABB

![ab](ab.png)
"""

import estructura
#Arbol Binario
#AB: valor(any), izq(AB), der(AB)
estructura.crear("AB","valor izq der")

abb=AB("F",\
    AB("B",\
        AB("A",None,None),\
        AB("D",\
            AB("C",None,None),\
            AB("E",None,None))),\
    AB("G",\
        None,\
        AB("I",\
            AB("H", None, None),\
            None)))

"""### Cómo encontrar un valor en un ABB"""

#buscaValor: any AB -> bool
#True si x está en arbol
#ej: buscaValor("A",abb)->True

def buscaValor(x,arbol):
    
    assert arbol==None or type(arbol)==AB
    if arbol==None: 
        return False
      
    elif arbol.valor==x:
        return True
    elif x < arbol.valor: 
        return buscaValor(x,arbol.izq)
    elif x > arbol.valor: 
        return buscaValor(x,arbol.der)
    
assert buscaValor("A",abb)

"""### Ejemplo: Cómo saber si un AB es un ABB?
Es decir, cómo sabemos si un árbol binario cumple con las condiciones para ser un árbol de búsqueda binario?
"""

#esABB: AB -> bool
#True si AB es un ABB
#ej: esABB(abb)->True

def esABB(arbol):
        
    assert arbol==None or type(arbol)==AB
    if arbol==None: 
        return True

    # debemos revisar que AB izquierdo sea ABB
    if esABBMenor(arbol.valor,arbol.izq) and esABBMayor(arbol.valor,arbol.der):
            return True
    else:
        return False
    
assert esABB(abb)
assert not esABB(AB("B",AB("C",None,AB("A",None,None)),None))

def esABBMenor(valor,arbol):
    if arbol == None:
        return True
    elif (arbol.valor < valor)\
             and esABBMenor(arbol.valor,arbol.izq)\
             and esABBMayor(arbol.valor,arbol.der):
        return True
    else:
        return False
    
assert esABBMenor("F", AB("B",\
                            AB("A",None,None),\
                            AB("D",\
                                AB("C",None,None),\
                                AB("E",None,None))))

def esABBMayor(valor,arbol):
    if arbol == None:
        return True
    elif (arbol.valor > valor) \
        and esABBMenor(arbol.valor,arbol.izq)\
        and esABBMayor(arbol.valor,arbol.der):
        return True
    else:
        return False
    
assert esABBMayor("F",AB("G",\
                            None,\
                            AB("I",\
                                  AB("H", None, None),\
                                  None)))

#escribir: AB -> None
#escribir valores de ABB A en orden ...
#ej: escribir(abb) -> ...

def escribir(arbol):
    assert arbol==None or type(arbol)==AB
    if arbol==None: 
        return
    
    escribir(arbol.izq)
    print(arbol.valor)
    escribir(arbol.der)

escribir(abb)

#insertar: any, AB -> AB
#nuevo ABB insertando x en ABB A
#ej: insertar("A",AB("B",None,None))->
#                 AB("B",AB("A",None,None),None)
def insertar(x,arbol):
   
    assert arbol==None or type(arbol)==AB
    if arbol==None: 
        return AB(x,None,None)
    
    assert x!=arbol.valor
    if x<arbol.valor: 
        return AB(arbol.valor, insertar(x,arbol.izq), arbol.der)
    if x>arbol.valor: 
        return AB(arbol.valor, arbol.izq, insertar(x,arbol.der) )

assert insertar("A",AB("B",None,None))== \
               AB("B",AB("A",None,None),None)